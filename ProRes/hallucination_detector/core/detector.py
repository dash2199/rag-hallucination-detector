"""
Main hallucination detector orchestrating multiple detection strategies.
"""

import time
from typing import List, Dict, Optional, Any
from loguru import logger

from hallucination_detector.config import (
    DetectorConfig, 
    DetectionStrategy, 
    AggregationMethod
)
from hallucination_detector.core.result import (
    DetectionResult, 
    StrategyResult, 
    HallucinationSpan,
    SeverityLevel,
)
from hallucination_detector.strategies.base import BaseStrategy
from hallucination_detector.strategies.semantic import SemanticSimilarityStrategy
from hallucination_detector.strategies.nli import NLIEntailmentStrategy
from hallucination_detector.strategies.entity import EntityVerificationStrategy
from hallucination_detector.strategies.claim import ClaimExtractionStrategy
from hallucination_detector.utils.text_processing import TextProcessor


class HallucinationDetector:
    """
    RAG-aware hallucination detector using multi-signal analysis.
    
    Combines multiple detection strategies to identify hallucinated content
    in generated text by verifying factual grounding against source documents.
    """
    
    def __init__(self, config: Optional[DetectorConfig] = None):
        """
        Initialize the hallucination detector.
        
        Args:
            config: Detection configuration. Uses defaults if not provided.
        """
        self.config = config or DetectorConfig()
        self.config.validate()
        
        self._strategies: Dict[DetectionStrategy, BaseStrategy] = {}
        self._text_processor = TextProcessor(
            chunk_size=self.config.chunk_size,
            chunk_overlap=self.config.chunk_overlap,
        )
        
        self._initialize_strategies()
        
        if self.config.verbose:
            logger.info(f"Initialized HallucinationDetector with strategies: {[s.value for s in self.config.strategies]}")
    
    def _initialize_strategies(self) -> None:
        """Initialize the configured detection strategies."""
        strategy_classes = {
            DetectionStrategy.SEMANTIC_SIMILARITY: SemanticSimilarityStrategy,
            DetectionStrategy.NLI_ENTAILMENT: NLIEntailmentStrategy,
            DetectionStrategy.ENTITY_VERIFICATION: EntityVerificationStrategy,
            DetectionStrategy.CLAIM_EXTRACTION: ClaimExtractionStrategy,
        }
        
        for strategy in self.config.strategies:
            if strategy in strategy_classes:
                self._strategies[strategy] = strategy_classes[strategy](
                    config=self.config
                )
                if self.config.verbose:
                    logger.debug(f"Initialized strategy: {strategy.value}")
    
    def detect(
        self,
        generated_text: str,
        source_documents: List[str],
        query: Optional[str] = None,
    ) -> DetectionResult:
        """
        Detect hallucinations in generated text.
        
        Args:
            generated_text: The text generated by the RAG system to analyze.
            source_documents: List of source documents used for retrieval.
            query: Optional original query that prompted the generation.
            
        Returns:
            DetectionResult with hallucination scores and spans.
        """
        start_time = time.time()
        
        if not generated_text.strip():
            return self._create_empty_result(generated_text, source_documents)
        
        if not source_documents:
            return self._create_no_source_result(generated_text, source_documents)
        
        # Preprocess text
        processed_generated = self._text_processor.preprocess(generated_text)
        processed_sources = [
            self._text_processor.preprocess(doc) for doc in source_documents
        ]
        
        # Run all strategies
        strategy_results: Dict[str, StrategyResult] = {}
        all_spans: List[HallucinationSpan] = []
        
        for strategy_type, strategy in self._strategies.items():
            try:
                result = strategy.detect(
                    generated_text=processed_generated,
                    source_documents=processed_sources,
                    query=query,
                )
                strategy_results[strategy_type.value] = result
                all_spans.extend(result.spans)
                
                if self.config.verbose:
                    logger.debug(
                        f"Strategy {strategy_type.value}: "
                        f"score={result.hallucination_score:.3f}, "
                        f"spans={len(result.spans)}"
                    )
            except Exception as e:
                logger.error(f"Strategy {strategy_type.value} failed: {e}")
                strategy_results[strategy_type.value] = StrategyResult(
                    strategy_name=strategy_type.value,
                    hallucination_score=0.5,
                    confidence=0.0,
                    details={"error": str(e)},
                )
        
        # Aggregate results
        final_score, confidence = self._aggregate_results(strategy_results)
        
        # Merge overlapping spans
        merged_spans = self._merge_spans(all_spans)
        
        # Determine final classification
        is_hallucinated = final_score >= self.config.thresholds.hallucination_threshold
        
        processing_time = time.time() - start_time
        
        return DetectionResult(
            generated_text=generated_text,
            source_documents=source_documents,
            hallucination_score=final_score,
            is_hallucinated=is_hallucinated,
            confidence=confidence,
            strategy_results=strategy_results,
            hallucination_spans=merged_spans,
            metadata={
                "processing_time_seconds": processing_time,
                "strategies_used": [s.value for s in self.config.strategies],
                "aggregation_method": self.config.aggregation_method.value,
                "query": query,
            },
        )
    
    def _aggregate_results(
        self, 
        strategy_results: Dict[str, StrategyResult]
    ) -> tuple[float, float]:
        """
        Aggregate results from multiple strategies.
        
        Returns:
            Tuple of (final_score, confidence)
        """
        if not strategy_results:
            return 0.5, 0.0
        
        if self.config.aggregation_method == AggregationMethod.WEIGHTED_AVERAGE:
            return self._weighted_average_aggregation(strategy_results)
        elif self.config.aggregation_method == AggregationMethod.MAX_SCORE:
            return self._max_score_aggregation(strategy_results)
        elif self.config.aggregation_method == AggregationMethod.VOTING:
            return self._voting_aggregation(strategy_results)
        else:
            return self._weighted_average_aggregation(strategy_results)
    
    def _weighted_average_aggregation(
        self, 
        strategy_results: Dict[str, StrategyResult]
    ) -> tuple[float, float]:
        """Weighted average of strategy scores."""
        total_weight = 0.0
        weighted_score = 0.0
        weighted_confidence = 0.0
        
        for strategy_type in self.config.strategies:
            strategy_name = strategy_type.value
            if strategy_name in strategy_results:
                result = strategy_results[strategy_name]
                weight = self.config.strategy_weights.get(strategy_type, 0.25)
                
                weighted_score += result.hallucination_score * weight * result.confidence
                weighted_confidence += result.confidence * weight
                total_weight += weight * result.confidence
        
        if total_weight > 0:
            final_score = weighted_score / total_weight
            final_confidence = weighted_confidence / len(strategy_results)
        else:
            final_score = 0.5
            final_confidence = 0.0
        
        return final_score, final_confidence
    
    def _max_score_aggregation(
        self, 
        strategy_results: Dict[str, StrategyResult]
    ) -> tuple[float, float]:
        """Use maximum hallucination score (most conservative)."""
        max_score = 0.0
        max_confidence = 0.0
        
        for result in strategy_results.values():
            if result.hallucination_score > max_score:
                max_score = result.hallucination_score
                max_confidence = result.confidence
        
        return max_score, max_confidence
    
    def _voting_aggregation(
        self, 
        strategy_results: Dict[str, StrategyResult]
    ) -> tuple[float, float]:
        """Majority voting on hallucination classification."""
        threshold = self.config.thresholds.hallucination_threshold
        votes_hallucinated = 0
        total_confidence = 0.0
        
        for result in strategy_results.values():
            if result.hallucination_score >= threshold:
                votes_hallucinated += 1
            total_confidence += result.confidence
        
        majority = votes_hallucinated > len(strategy_results) / 2
        final_score = votes_hallucinated / len(strategy_results)
        avg_confidence = total_confidence / len(strategy_results)
        
        return final_score, avg_confidence
    
    def _merge_spans(self, spans: List[HallucinationSpan]) -> List[HallucinationSpan]:
        """Merge overlapping hallucination spans."""
        if not spans:
            return []
        
        # Sort by start position
        sorted_spans = sorted(spans, key=lambda x: (x.start_char, -x.end_char))
        merged = []
        
        current = sorted_spans[0]
        for span in sorted_spans[1:]:
            if span.start_char <= current.end_char:
                # Overlapping spans - merge
                if span.end_char > current.end_char:
                    # Extend the span
                    current = HallucinationSpan(
                        start_char=current.start_char,
                        end_char=span.end_char,
                        text=current.text,  # Keep original text for now
                        hallucination_type=self._merge_types(
                            current.hallucination_type, 
                            span.hallucination_type
                        ),
                        severity=max(current.severity, span.severity, key=lambda x: x.value),
                        confidence=max(current.confidence, span.confidence),
                        evidence={**current.evidence, **span.evidence},
                        explanation=f"{current.explanation}; {span.explanation}",
                    )
            else:
                merged.append(current)
                current = span
        
        merged.append(current)
        return merged
    
    def _merge_types(self, type1, type2):
        """Merge two hallucination types, preferring more specific ones."""
        from hallucination_detector.core.result import HallucinationType
        
        priority = {
            HallucinationType.FACTUAL_ERROR: 5,
            HallucinationType.ENTITY_FABRICATION: 4,
            HallucinationType.NUMERICAL_ERROR: 4,
            HallucinationType.TEMPORAL_ERROR: 4,
            HallucinationType.ATTRIBUTION_ERROR: 3,
            HallucinationType.UNSUPPORTED_CLAIM: 2,
            HallucinationType.EXTRINSIC_INFO: 1,
        }
        return type1 if priority.get(type1, 0) >= priority.get(type2, 0) else type2
    
    def _create_empty_result(
        self, 
        generated_text: str, 
        source_documents: List[str]
    ) -> DetectionResult:
        """Create result for empty generated text."""
        return DetectionResult(
            generated_text=generated_text,
            source_documents=source_documents,
            hallucination_score=0.0,
            is_hallucinated=False,
            confidence=1.0,
            metadata={"note": "Empty generated text"},
        )
    
    def _create_no_source_result(
        self, 
        generated_text: str, 
        source_documents: List[str]
    ) -> DetectionResult:
        """Create result when no source documents provided."""
        return DetectionResult(
            generated_text=generated_text,
            source_documents=source_documents,
            hallucination_score=1.0,
            is_hallucinated=True,
            confidence=0.5,
            hallucination_spans=[
                HallucinationSpan(
                    start_char=0,
                    end_char=len(generated_text),
                    text=generated_text,
                    hallucination_type=HallucinationType.UNSUPPORTED_CLAIM,
                    severity=SeverityLevel.HIGH,
                    confidence=0.5,
                    explanation="No source documents provided for verification",
                )
            ],
            metadata={"note": "No source documents provided"},
        )
    
    async def detect_async(
        self,
        generated_text: str,
        source_documents: List[str],
        query: Optional[str] = None,
    ) -> DetectionResult:
        """
        Async version of detect for high-throughput scenarios.
        
        Args:
            generated_text: The text generated by the RAG system.
            source_documents: List of source documents.
            query: Optional original query.
            
        Returns:
            DetectionResult with hallucination analysis.
        """
        import asyncio
        
        # Run CPU-intensive detection in thread pool
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None,
            self.detect,
            generated_text,
            source_documents,
            query,
        )
    
    def detect_batch(
        self,
        items: List[Dict[str, Any]],
    ) -> List[DetectionResult]:
        """
        Process multiple detection requests in batch.
        
        Args:
            items: List of dicts with 'generated_text', 'source_documents', 
                   and optional 'query' keys.
                   
        Returns:
            List of DetectionResults.
        """
        results = []
        for item in items:
            result = self.detect(
                generated_text=item["generated_text"],
                source_documents=item["source_documents"],
                query=item.get("query"),
            )
            results.append(result)
        return results


# Import for type annotation
from hallucination_detector.core.result import HallucinationType

